# v0.1 - Scaffolding & Basic API

**Status**:
- [ ] Planned
- [x] In Progress
- [ ] Complete

**Start Date**: December 7, 2025

**Completion Date**: TBD

**Last Updated**: December 7, 2025

---

## Overview

This initial version sets up the foundational architecture for Nyte, including a basic NestJS backend API and a React web client. The focus is on establishing core functionality such as media scanning, metadata retrieval, and basic video playback.

---

## Success Criteria

- [ ] Backend server starts and serves API endpoints
- [ ] Web client connects to backend and displays a list of media
- [ ] Media files can be played back in the web client
- [ ] Basic configuration management is implemented
- [ ] All code passes linting and tests

---

## Features

### Backend

#### 1. Basic API Setup
- [ ] Backend server starts and serves API endpoints
- [ ] Health check endpoint implemented

#### 2. Media Scanning
- [ ] Service to scan specified directories for media files
- [ ] Basic metadata extraction (filename, size, modified date)
- [ ] In-memory storage of scanned media data

#### 3. Media Streaming
- [ ] Endpoint to stream media files directly
- [ ] Streams .mp4 files with proper headers
- [ ] Basic error handling for missing files

---

### Frontend

#### 1. Basic Web Client
- [ ] Web client connects to backend and displays a list of media
- [ ] Media files can be played back in the web client
- [ ] Simple UI with a list view of media items
- [ ] Video player component for playback of .mp4 files

---

### Miscellaneous

#### 1. Basic Configuration Management
- [ ] Environment variable support for configuration
- [ ] Configurable media directories for scanning

---

## Technical Decisions

### 1. NestJS for Backend
Chosen for its modular architecture, TypeScript support, and strong community. It provides a solid foundation for building scalable server-side applications. Implementing my own version of an architecture would have delayed progress significantly and increased complexity. NestJS is widely adopted and has many built-in features that align with what Nyte needs.

### 2. Node.js over Deno, Bun, or Others
Node.js was selected due to its maturity, extensive ecosystem, and compatibility with existing libraries. While Deno and Bun offer modern features, they lack the same level of community support and library availability, which could hinder development speed and increase maintenance overhead.

### 3. React for Frontend
React was chosen for its component-based architecture, vast ecosystem, and strong community support. It allows for rapid development of interactive UIs and has excellent integration with TypeScript, which is a core part of Nyte's technology stack. Other frameworks like Vue or Angular were considered, but React's flexibility and popularity made it the preferred choice.

### 4. In-Memory Storage for v0.1
For the initial version, in-memory storage was chosen for simplicity and speed of development. This allows for quick iteration without the overhead of setting up a database. Future versions will implement persistent storage solutions as needed.

### 5. Direct .mp4 Streaming
Direct streaming of .mp4 files was implemented to provide a straightforward playback experience without the complexity of transcoding or adaptive streaming. This keeps the initial implementation simple and allows focus on core functionality. More advanced streaming techniques will be explored in later versions.

### 6. Environment Variables for Configuration
Using environment variables allows for flexible configuration across different environments (development, production) without changing code. This is a standard practice in modern application development and helps keep sensitive information out of the codebase. More advanced configuration management, such as using a database, will be considered in future versions.

### 7. TypeScript Throughout
TypeScript was chosen for its static typing, which helps catch errors early in the development process and improves code maintainability. Using TypeScript across both backend and frontend ensures consistency and allows for shared types and interfaces, reducing duplication and potential mismatches. While languages like Rust or Go offer performance benefits, TypeScript's developer experience and ecosystem are better suited for the rapid development needs of Nyte. Tauri is also being explored for desktop/mobile clients, leveraging TypeScript for the web components.

### 8. Monorepo Structure
A monorepo structure was adopted to manage the multiple packages (backend, web client, shared libraries) within a single repository. This simplifies dependency management, code sharing, and versioning across the different parts of the application. Future clients that do not share code with the web client (e.g., Roku, Tizen) may be developed in separate repositories to reduce complexity.

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Delays in setting up core architecture | High | Start with minimal viable features, iterate quickly |
| Choice of technologies may not scale | Medium | Regularly review technology choices, stay updated with community trends |
| Incomplete feature implementation | Medium | Define clear success criteria, prioritize core features |
| Lack of community support for chosen libraries | Low | Choose widely adopted libraries, contribute to open source if needed |

---

## Next Steps

See [v0.2 roadmap](./v0.2.md) for details.

---

See individual version documents in docs/roadmap for detailed feature breakdowns and technical specifications.